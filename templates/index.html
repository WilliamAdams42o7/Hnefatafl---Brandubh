<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Hnefatafl</title>
    <style>
        html,body { height:100%; margin:0; font-family: sans-serif; }

        body.attacker-turn { background-color: #ffcccc; transition: background-color 0.3s ease; }
        body.defender-turn { background-color: #cce0ff; transition: background-color 0.3s ease; }
        body.attacker-win  { background-color: #ad2f2f !important; }
        body.defender-win  { background-color: #2c6bab !important; }

        .container { max-width:520px; margin:18px auto; text-align:center; }
        table { border-collapse: collapse; margin: 10px auto; }
        td {
            width: 60px;
            height: 60px;
            border: 1px solid #333;
            padding:0;
            position: relative;
            box-sizing: border-box;
        }
        td.light { background-color: #deb887; }
        td.dark  { background-color: #85542a; }
        td.selected { outline: 3px solid yellow; outline-offset: -3px; }
        #status { text-align: center; font-size: 16px; margin-top: 8px; min-height:22px; }
        #mode-buttons { margin: 10px 0; }
        button { padding: 8px 12px; margin: 4px; }
        #board { border: 4px solid black; display: inline-block; }
        svg.square-svg { display:block; margin:auto; }

        /* rules section */
        #rules-container { max-width:520px; margin: 20px auto; text-align:left; border:1px solid #333; padding:10px; }
        #rules-container h2 { text-align:center; margin-top:0; }
    </style>
</head>

<body id="page">
    <div class="container">
        <div id="mode-buttons">
            <button onclick="startGame('PvP')">Player vs Player</button>
            <button onclick="startGame('AI_Attacker_vs_Player')">Opponent (Attacker) vs Player (Defender)</button>
            <button onclick="startGame('Player_vs_AI_Defender')">Player (Attacker) vs Opponent (Defender)</button>
            <button onclick="startGame('AI_vs_AI')">Opponent vs Opponent</button>
        </div>

        <div id="status">Press "Player vs Player" to start</div>
        <table id="board" aria-label="Hnefatafl board"></table>
    </div>

    <!-- Rules Section -->
    <div id="rules-container">
        <h2>Game Rules</h2>
        <h3>Sides and Setup</h3>
        <p>     There are two sides: Attackers (Red) and Defenders (Blue).</p>
        <p>     The Attackers have eight pieces.</p>
        <p>     The Defenders have five pieces: the King and four defenders.</p>
        <p>     Attackers (Red) move first.</p>

        <h3>Movement</h3>
        <p>     All pieces move orthogonally (up, down, left, right), like a rook in chess.</p>
        <p>     Pieces may move any number of squares in a straight line.</p>
        <p>     Pieces may not jump over or land on another piece.</p>

        <h3>Special Squares</h3>
        <p>     The Throne is the marked square in the centre of the board.</p>
        <p>     The King starts on the Throne.</p>
        <p>     No piece may land on the Throne after the King leaves, including the King.</p>
        <p>     The Corner Squares are marked.</p>
        <p>     Only the King may land on corner squares.</p>
        <p>     Corner squares are hostile to all pieces, including the King.</p>

        <h3>Capturing</h3>
        <p>     A piece is captured when it is sandwiched orthogonally on two directly opposite sides by enemy pieces.</p>
        <p>     Captures occur only when a piece moves into position to complete the sandwich.</p>
        <p>     A piece may move between two hostile pieces without being captured.</p>
        <p>     The King is armed and may participate in captures like any other piece.</p>

        <h3>Special Squares</h3>
        <p>     The Throne is always hostile to Attackers.</p>
        <p>     An Attacker may be captured between the Throne and a Defender.</p>
        <p>     If the Throne is empty, it is also hostile to Defenders.</p>
        <p>     If the King is on the Throne, the Throne is not hostile to the King.</p>
        <p>     Corner squares are hostile to all pieces, including the King.</p>
        <p>     A piece may be captured by being sandwiched between a corner square and an enemy piece.</p>

        <h3>Capturing the King</h3>
        <p>     When the King is on the Throne, he must be surrounded on all four sides by Attackers to be captured.</p>
        <p>     When the King is adjacent to the Throne, he must be surrounded on the remaining three sides by Attackers.</p>
        <p>     Elsewhere on the board, the King is captured normally, by two opposing pieces.</p>

        <h3>Victory Conditions</h3>
        <p><strong>Attackers (Red) win if:</strong></p>
        <p>     They capture the King, or</p>
        <p>     All Defending pieces are surrounded.</p>

        <p><strong>Defenders (Blue) win if:</strong></p>
        <p>     The King escapes by reaching any corner square.</p>

        <p><strong>If a player cannot make any valid move, they lose the game.<strong></p>
        </div>

<script>
const SPECIAL_SQUARES = [[3,3],[0,0],[0,6],[6,0],[6,6]];
let selected = null;
let gameOver = false;
let currentBoard = null;
let currentTurn = null;
let tickInterval = null;
const TICK_MS = 400;

/* ------------------ UI helpers ------------------ */
function updateBackground() {
    const body = document.getElementById("page");

    body.classList.remove(
        "attacker-turn",
        "defender-turn",
        "attacker-win",
        "defender-win"
    );

    if (gameOver) {
        if (currentTurn === "attacker") body.classList.add("attacker-win");
        if (currentTurn === "defender") body.classList.add("defender-win");
        return;
    }

    if (currentTurn === "attacker") body.classList.add("attacker-turn");
    else if (currentTurn === "defender") body.classList.add("defender-turn");
}

/* ------------------ TICK /tick ------------------ */
function startTicking() {
    if (tickInterval) return;

    tickInterval = setInterval(() => {
        fetch("/tick", {
            method: "POST",
            headers: { "Content-Type": "application/json" }
        })
        .then(res => res.json())
        .then(data => {
            if (!data) return;
            if (data.board) {
                currentBoard = data.board;
                currentTurn = data.current_turn;
                gameOver = !!data.game_over;
                renderBoard(currentBoard);
                updateBackground();
                if (gameOver) {
                    document.getElementById('status').innerText =
                        "Winner: " +
                        (data.winner === "attacker" ? "Attacker" :
                         data.winner === "defender" ? "Defender" : "Winner");

                    stopTicking();
                } else {
                    document.getElementById('status').innerText =
                        "Turn: " + (currentTurn === "attacker" ? "Attacker" : "Defender");
                }
            }
        })
        .catch(err => console.error("Tick error:", err));
    }, TICK_MS);
}

function stopTicking() {
    if (!tickInterval) return;
    clearInterval(tickInterval);
    tickInterval = null;
}

/* ------------------ Start Game ------------------ */
function startGame(mode) {
    fetch('/start_game', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ mode })
    }).then(res => res.json())
      .then(data => {
          currentBoard = data.board;
          gameOver = !!data.game_over;
          selected = null;
          currentTurn = data.current_turn;

          document.getElementById('status').innerText =
              "Game started: " + (mode || 'PvP');

          renderBoard(currentBoard);
          updateBackground();

          startTicking();
      })
      .catch(err => {
          console.error(err);
          alert('Could not start game.');
      });
}

/* ------------------ Render Board ------------------ */
function renderBoard(board) {
    const table = document.getElementById('board');
    table.innerHTML = '';

    board.forEach((row, r) => {
        const tr = document.createElement('tr');

        row.forEach((cell, c) => {
            const td = document.createElement('td');
            td.dataset.row = r;
            td.dataset.col = c;
            td.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');

            if (selected && selected[0] === r && selected[1] === c) {
                td.classList.add('selected');
            }

            const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
            svg.setAttribute('class','square-svg');
            svg.setAttribute('width','60');
            svg.setAttribute('height','60');
            svg.setAttribute('viewBox','0 0 60 60');

            if (SPECIAL_SQUARES.some(pos => pos[0] === r && pos[1] === c)) {
                const crossSize = 45;
                const offset = (60 - crossSize) / 2;

                const line1 = document.createElementNS('http://www.w3.org/2000/svg','line');
                line1.setAttribute('x1', offset);
                line1.setAttribute('y1', offset);
                line1.setAttribute('x2', offset + crossSize);
                line1.setAttribute('y2', offset + crossSize);
                line1.setAttribute('stroke','black');
                line1.setAttribute('stroke-width','3');
                svg.appendChild(line1);

                const line2 = document.createElementNS('http://www.w3.org/2000/svg','line');
                line2.setAttribute('x1', offset + crossSize);
                line2.setAttribute('y1', offset);
                line2.setAttribute('x2', offset);
                line2.setAttribute('y2', offset + crossSize);
                line2.setAttribute('stroke','black');
                line2.setAttribute('stroke-width','3');
                svg.appendChild(line2);
            }

            if (cell) {
                const cx = 30;
                const rx = 20;
                const ry = 10;
                const topY = 25;
                const bottomY = 30;

                const fillColor = cell.is_king ? "#009999" :
                                  (cell.team === "attacker" ? "#ff6666" : "#66cccc");

                const sideColor = cell.is_king ? "#007777" :
                                  (cell.team === "attacker" ? "#cc0000" : "#339999");

                const bottom = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
                bottom.setAttribute("cx", cx);
                bottom.setAttribute("cy", bottomY);
                bottom.setAttribute("rx", rx);
                bottom.setAttribute("ry", ry);
                bottom.setAttribute("fill", sideColor);
                bottom.setAttribute("stroke", "black");
                bottom.setAttribute("stroke-width", 2);
                svg.appendChild(bottom);

                const leftLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                leftLine.setAttribute("x1", cx - rx);
                leftLine.setAttribute("y1", topY);
                leftLine.setAttribute("x2", cx - rx);
                leftLine.setAttribute("y2", bottomY);
                leftLine.setAttribute("stroke", "black");
                leftLine.setAttribute("stroke-width", 2);
                svg.appendChild(leftLine);

                const rightLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                rightLine.setAttribute("x1", cx + rx);
                rightLine.setAttribute("y1", topY);
                rightLine.setAttribute("x2", cx + rx);
                rightLine.setAttribute("y2", bottomY);
                rightLine.setAttribute("stroke", "black");
                rightLine.setAttribute("stroke-width", 2);
                svg.appendChild(rightLine);

                const top = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
                top.setAttribute("cx", cx);
                top.setAttribute("cy", topY);
                top.setAttribute("rx", rx);
                top.setAttribute("ry", ry);
                top.setAttribute("fill", fillColor);
                top.setAttribute("stroke", "black");
                top.setAttribute("stroke-width", 2);
                svg.appendChild(top);

                if (cell.is_king) {
                    const crossHalf = 10;

                    const h = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    h.setAttribute("x1", cx - crossHalf);
                    h.setAttribute("y1", topY);
                    h.setAttribute("x2", cx + crossHalf);
                    h.setAttribute("y2", topY);
                    h.setAttribute("stroke","black");
                    h.setAttribute("stroke-width","3");
                    svg.appendChild(h);

                    const v = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    v.setAttribute("x1", cx);
                    v.setAttribute("y1", topY - crossHalf);
                    v.setAttribute("x2", cx);
                    v.setAttribute("y2", topY + crossHalf);
                    v.setAttribute("stroke","black");
                    v.setAttribute("stroke-width","3");
                    svg.appendChild(v);
                }
            }

            td.appendChild(svg);

            td.addEventListener('click', () => {
                if (gameOver) return;

                if (!selected) {
                    selected = [r, c];
                    renderBoard(board);
                    return;
                }

                if (selected[0] === r && selected[1] === c) {
                    selected = null;
                    renderBoard(board);
                    return;
                }

                const start = selected;
                const end = [r, c];
                selected = null;
                renderBoard(board);

                fetch('/make_move', {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify({ start, end })
                }).then(async res => {
                    const data = await res.json().catch(()=>null);

                    if (!res.ok) {
                        if (data && data.board) {
                            currentBoard = data.board;
                            renderBoard(currentBoard);
                        }
                        alert('Move rejected: ' +
                              (data && data.error ? data.error : 'Illegal move'));
                        return;
                    }

                    currentBoard = data.board;
                    currentTurn = data.current_turn;
                    gameOver = data.game_over;

                    document.getElementById('status').innerText =
                        data.game_over ?
                            ("Winner: " +
                             (data.winner === "attacker" ? "Attacker" :
                              data.winner === "defender" ? "Defender" :
                              "Winner")) :
                            ("Turn: " +
                             (currentTurn === "attacker" ? "Attacker" :
                              "Defender"));

                    renderBoard(currentBoard);
                    updateBackground();

                    if (!gameOver) startTicking();
                }).catch(err => {
                    console.error(err);
                    alert('Network error.');
                    if (currentBoard) renderBoard(currentBoard);
                });
            });

            tr.appendChild(td);
        });

        table.appendChild(tr);
    });
}

renderBoard(Array.from({length:7}, ()=>Array.from({length:7}, ()=>null)));
updateBackground();
</script>
</body>
</html>

